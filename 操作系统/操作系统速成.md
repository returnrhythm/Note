## 进程管理
进程是系统分配资源的基本单位
### 调度的三个层次
1. 高级调度：从外存中选作业调入内存
2. 中级调度：从阻塞队列中选进程调入内存
3. 低级调度：从就绪队列中选进程分配处理机
### 调度时产生的数据
1. 系统吞吐量：作业数/时间
2. cpu利用率：有效时间/有效时间+空闲时间
3. 周转时间：完成时间-提交时间
4. 平均周转时间：总周转时间/作业数
5. 带权周转时间：周转时间/运行时间
### 调度算法
1. 先来先服务(FCFS)
2. 短作业优先(SJF)：谁运行时间短就运行谁，平均等待时间，平均周转时间最小
3. 多级反馈队列：设置不同优先级的队列，优先选择高优先级队列执行，每个队列按照先来先服务原则
4. 高响应比(HRRN)：等待时间+运行时间/运行时间，谁高运行谁
5. 时间片轮转(RR)：按照就绪队列顺序，每个进程执行一个时间片的时间
### 算时间
在后面写开始时间 结束时间 周转时间 带权周转时间
### 死锁
#### 4个必要条件
1. 互斥：资源是互斥的
2. 不剥夺：资源不能抢走
3. 请求保持：拿着一个资源又请求另一个资源
4. 循环等待：进程间相互等待对方的资源
#### 银行家算法：避免死锁
1. 求剩余资源
2. 求还需要的资源
3. 新增两列，现有资源，现有资源+已分配资源，如果剩余资源>=还需要资源就可以执行，此时那一列的现有资源+已分配资源可以计算，下一列的现有资源的数值也变成它
#### 死锁解除
1. 资源剥夺法：挂起死锁进程，剥夺他的资源
2. 撤销进程法：撤销部分或者所有死锁进程
3. 进程回退法：回退到发生死锁之前的时候
## 内存管理
### 源程序变为可执行的程序步骤
#### 编译
源代码翻译成机器语言
#### 链接
链接目标模块和库函数  
链接方式：
1. 静态链接：一开始就链接
2. 装入时动态链接：在装入内存时链接
3. 运行时动态链接：运行时需要再链接
#### 装入
装入内存形成物理地址
装入方式：
1. 绝对装入：编译时就知道物理地址
2. 静态可重定位装入：设定一个偏移量，物理地址等于偏移量+逻辑地址
3. 动态运行时装入，每个模块有一个重定位寄存器，里面存放偏移量(不同模块可以不连续放)
### 覆盖
程序被分为多个段，常用的常驻内存，不常用的需要时调入内存
### 交换
内存紧张时，暂时把某些进程拿出去放到外村，把一些进程放回内存
### 连续分配管理
1. 单一连续分配
2. 固定分区分配
3. 动态分区分配
#### 动态分区分配的算法
1. 首次适应FF
2. 最佳适应BF
3. 最坏适应WF
4. 邻近适应
### 非连续分配
#### 基本分页存储
进程被分为块，称为页，内存被分为块，称为页框，页大小等于页框大小(页放入页框，也可以说进程放入内存)每个页有一个页号(隐含的)，每个页号对应一个块号(物理的)，每个页大小相等
##### 根据页表求地址
1. 根据逻辑地址求出页号和页内地址(偏移量)
2. 物理地址=页的大小*逻辑地址页页号对应的块号+偏移量
#### 分段存储
进程按照逻辑分为段，每个段都有段名，每一个段有段表项，记录段长和基址，每个段表项长度一样
### 页面置换算法
1. 最佳置换算法(OPT)：淘汰的是以后永不使用或者在最长时间不再被访问的页面，无法实现
2. 先进先出(FIFO)：淘汰最早进入的页面
3. 最近最久未使用(LRU)：淘汰的是最长时间没访问的页面
4. 近期最少使用(LFU)：淘汰近期访问最少的页面
### 页面抖动
刚换出到外存又要调入内存，刚调入内存又要换出外存    
原因：物理块不足，内存驻留的进程又太多
### 解决页面抖动的页面置换策略
1. 固定分配 局部置换：物理块数量一定，发生缺页就在自己的物理块调出调入，缺点：不好确定一个进程分配多大的实际内存
2. 可变分配 全局置换：物理块数量可变，发生缺页就给他分配一个空闲物理块，空闲物理块用完之后可以调用别的进程的物理块，缺点：别的进程物理块少了，缺页率上升
3. 可变分配 局部置换：物理块数量和可变，发生缺页在自己的物理块调入调出，系统根据缺页率动态增加或者减少一些物理块